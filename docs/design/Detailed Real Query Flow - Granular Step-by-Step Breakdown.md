You're absolutely right! I was merging multiple core technologies into black boxes. Let me split the steps to show the actual granular processing based on the **real codebase**:

## **Detailed Real Query Flow - Granular Step-by-Step Breakdown**

| **Step** | **Component** | **Input** | **Expected Output** | **Core Technology** |
|----------|---------------|-----------|---------------------|-------------------|
| **1. User Input** | React Frontend | User types: `"pump bearing failure"` | ```typescript<br/>query: "pump bearing failure"<br/>setQuery("pump bearing failure")``` | React useState hooks |
| **2. Form Submission** | React handleSubmit() | ```typescript<br/>e: React.FormEvent<br/>query: "pump bearing failure"``` | ```typescript<br/>setLoading(true)<br/>setError(null)<br/>axios.post() call``` | React event handlers |
| **3. HTTP Request** | axios.post() | ```typescript<br/>QueryRequest {<br/>  query: "pump bearing failure",<br/>  max_results: 10,<br/>  include_explanations: true,<br/>  enable_safety_warnings: true<br/>}``` | ```typescript<br/>HTTP POST to:<br/>"http://localhost:8000/api/v1/query/structured/"<br/>Content-Type: application/json``` | axios HTTP client |
| **4. API Reception** | FastAPI Router | ```python<br/>request: QueryRequest``` | ```python<br/>router validation passed<br/>process_structured_query() called<br/>start_time = time.time()``` | FastAPI + Pydantic validation |
| **5. Component Check** | get_rag_system() | ```python<br/>Dependency injection call``` | ```python<br/>rag_system: MaintIEEnhancedRAG<br/>components_initialized: True<br/>OR HTTPException(503) if not ready``` | FastAPI Depends() |
| **6. Cache Check** | Structured RAG | ```python<br/>query: "pump bearing failure"<br/>max_results: 10``` | ```python<br/>cached_response: None (cache miss)<br/>OR RAGResponse (cache hit - return early)``` | Response caching system |
| **7a. Query Normalization** | _normalize_query() | ```python<br/>query: "pump bearing failure"``` | ```python<br/>normalized_query: "pump bearing failure"<br/># No abbreviations to expand in this case``` | re.sub() + domain abbreviations |
| **7b. Entity Extraction** | _extract_entities() | ```python<br/>normalized_query: "pump bearing failure"``` | ```python<br/>entities: ["pump", "bearing", "failure"]<br/># From equipment_patterns, failure_patterns``` | Regex patterns + domain vocabulary |
| **7c. Query Classification** | _classify_query_type() | ```python<br/>normalized_query: "pump bearing failure"``` | ```python<br/>query_type: QueryType.TROUBLESHOOTING<br/># "failure" keyword match``` | Domain knowledge keywords |
| **7d. Intent Detection** | _detect_intent() | ```python<br/>query: "pump bearing failure"<br/>query_type: TROUBLESHOOTING``` | ```python<br/>intent: "failure_analysis"<br/># "failure" in troubleshooting patterns``` | Intent pattern matching |
| **7e. Complexity Assessment** | _assess_complexity() | ```python<br/>query: "pump bearing failure"<br/>entities: ["pump", "bearing", "failure"]``` | ```python<br/>complexity: "medium"<br/># complexity_score = 1 (3 entities)``` | Scoring algorithm |
| **7f. Urgency Determination** | _determine_urgency() | ```python<br/>query: "pump bearing failure"``` | ```python<br/>urgency: "high"<br/># "failure" in high_urgency keywords``` | Keyword-based urgency mapping |
| **7g. Equipment Categorization** | _identify_equipment_category() | ```python<br/>entities: ["pump", "bearing", "failure"]``` | ```python<br/>equipment_category: "rotating_equipment"<br/># "pump" matches equipment_hierarchy``` | Equipment hierarchy lookup |
| **7h. GNN Enhancement** | _gnn_enhanced_analysis() | ```python<br/>analysis: QueryAnalysis``` | ```python<br/>enhanced_analysis: QueryAnalysis<br/>domain_context: {"equipment_focus": 0.85}<br/>confidence: 0.95 (boosted)``` | GNN domain context (if enabled) |
| **8a. Safety Assessment** | _assess_safety_criticality() | ```python<br/>entities: ["pump", "bearing", "failure"]<br/>query_type: TROUBLESHOOTING``` | ```python<br/>safety_assessment: {<br/>  "is_safety_critical": True,<br/>  "safety_level": "high",<br/>  "critical_equipment": ["pump"]<br/>}``` | Safety critical equipment lookup |
| **8b. Concept Expansion** | _enhanced_expand_concepts() | ```python<br/>entities: ["pump", "bearing", "failure"]``` | ```python<br/>expanded_concepts: [<br/>  "centrifugal pump", "bearing wear",<br/>  "vibration analysis", "shaft alignment"<br/>]``` | Domain knowledge + rule-based expansion |
| **8c. Related Entity Finding** | _find_related_entities() | ```python<br/>entities: ["pump", "bearing", "failure"]``` | ```python<br/>related_entities: ["seal", "impeller", "coupling"]<br/># Via NetworkX graph traversal``` | NetworkX.neighbors() + shortest_path |
| **8d. Domain Context Addition** | _add_domain_context() | ```python<br/>analysis: QueryAnalysis``` | ```python<br/>domain_context: {<br/>  "task_urgency": "high",<br/>  "equipment_focus": 0.85,<br/>  "safety_focus": 0.72<br/>}``` | Domain knowledge context |
| **8e. Structured Search Building** | _build_structured_search() | ```python<br/>entities: ["pump", "bearing", "failure"]<br/>expanded_concepts: [...]``` | ```python<br/>structured_search: "pump bearing failure centrifugal bearing wear vibration"``` | Query concatenation algorithm |
| **8f. Safety Considerations** | _identify_safety_considerations() | ```python<br/>entities: ["pump", "bearing", "failure"]<br/>expanded_concepts: [...]``` | ```python<br/>safety_considerations: [<br/>  "Immediate shutdown required",<br/>  "PPE mandatory for inspection"<br/>]``` | Safety rules engine |
| **9a. Embedding Generation** | Azure OpenAI API | ```python<br/>text: "pump bearing failure centrifugal bearing wear vibration"``` | ```python<br/>embedding_response: {<br/>  "data": [{"embedding": [0.1, -0.2, 0.8, ...]}]<br/>}<br/># 1536 dimensions``` | AzureOpenAI.embeddings.create() |
| **9b. Embedding Processing** | NumPy + FAISS prep | ```python<br/>raw_embedding: List[float]``` | ```python<br/>embedding: np.array([0.1, -0.2, 0.8, ...])  # shape: (1, 1536)<br/>normalized_embedding: L2 normalized``` | np.array() + faiss.normalize_L2() |
| **10a. FAISS Index Search** | FAISS IndexFlatIP | ```python<br/>query_embedding: np.array(1536,)<br/>top_k: 10``` | ```python<br/>scores: [0.94, 0.89, 0.86, 0.84, 0.81, ...]<br/>indices: [142, 67, 203, 89, 156, ...]``` | faiss.IndexFlatIP.search() |
| **10b. Document Retrieval** | Document lookup | ```python<br/>indices: [142, 67, 203, ...]<br/>scores: [0.94, 0.89, 0.86, ...]``` | ```python<br/>raw_results: [<br/>  {"doc_id": "doc_142", "title": "Pump Bearing Maintenance", "content": "..."},<br/>  {"doc_id": "doc_67", "title": "Vibration Analysis", "content": "..."},<br/>  ...<br/>]``` | Document database + metadata lookup |
| **11a. Vector Scoring** | Score calculation | ```python<br/>raw_results with FAISS scores``` | ```python<br/>vector_scores: [0.94, 0.89, 0.86, ...]<br/># Cosine similarity scores``` | FAISS similarity calculation |
| **11b. Graph Ranking** | GraphEnhancedRanker | ```python<br/>entities: ["pump", "bearing", "failure"]<br/>vector_scores: [0.94, 0.89, ...]``` | ```python<br/>graph_scores: [0.85, 0.78, 0.92, ...]<br/># Based on graph distance to entities``` | NetworkX graph distance calculation |
| **11c. Fusion Scoring** | Weighted combination | ```python<br/>vector_scores: [0.94, 0.89, 0.86, ...]<br/>graph_scores: [0.85, 0.78, 0.92, ...]``` | ```python<br/>final_scores: [<br/>  0.7*0.94 + 0.3*0.85 = 0.913,<br/>  0.7*0.89 + 0.3*0.78 = 0.857,<br/>  0.7*0.86 + 0.3*0.92 = 0.878<br/>]``` | Weighted fusion (70% vector, 30% graph) |
| **12. Search Results Assembly** | SearchResult objects | ```python<br/>enhanced_docs + final_scores``` | ```python<br/>search_results: [<br/>  SearchResult(doc_id="doc_142", title="Pump Bearing Maintenance", score=0.913, source="vector", entities=["pump", "bearing"]),<br/>  SearchResult(doc_id="doc_203", title="Bearing Failure Analysis", score=0.878, source="vector", entities=["bearing", "failure"]),<br/>  ...<br/>]``` | SearchResult object creation |
| **13a. Prompt Building** | _build_maintenance_prompt() | ```python<br/>enhanced_query: EnhancedQuery<br/>search_results: List[SearchResult]``` | ```python<br/>maintenance_prompt: """You are a maintenance expert...<br/>Query Type: troubleshooting<br/>Equipment Category: rotating_equipment<br/>⚠️ SAFETY CRITICAL EQUIPMENT DETECTED ⚠️<br/>Relevant Documentation:<br/>1. Pump Bearing Maintenance (Domain Relevance: 0.85)<br/>   Centrifugal pump bearing failure indicators...<br/>Instructions: 1. Provide comprehensive response..."""``` | Domain-specific prompt template |
| **13b. LLM API Call** | _call_openai() | ```python<br/>maintenance_prompt: str``` | ```python<br/>openai_response: {<br/>  "choices": [{"message": {"content": "⚠️ SAFETY CRITICAL: Pump bearing failure requires immediate attention..."}}]<br/>}``` | AzureOpenAI.chat.completions.create() |
| **13c. Response Enhancement** | _enhance_response() | ```python<br/>raw_response: str<br/>enhanced_query: EnhancedQuery``` | ```python<br/>generation_result: {<br/>  "generated_response": "⚠️ SAFETY CRITICAL: Pump bearing failure requires immediate attention...",<br/>  "confidence_score": 0.94,<br/>  "sources": ["doc_142", "doc_203", "doc_67"],<br/>  "safety_warnings": ["Immediate shutdown required", "PPE mandatory"],<br/>  "citations": ["Pump Maintenance Manual Section 4.2", ...]<br/>}``` | Safety injection + citation processing |
| **14. RAG Response Assembly** | Pipeline Assembly | ```python<br/>All previous outputs``` | ```python<br/>RAGResponse(<br/>  query="pump bearing failure",<br/>  enhanced_query=EnhancedQuery,<br/>  search_results=List[SearchResult],<br/>  generated_response="⚠️ SAFETY CRITICAL...",<br/>  confidence_score=0.94,<br/>  processing_time=1.24,<br/>  sources=["doc_142", "doc_203", "doc_67"],<br/>  safety_warnings=["Immediate shutdown required", "PPE mandatory"],<br/>  citations=[...]<br/>)``` | Response object assembly |
| **15. Cache Update** | Conditional caching | ```python<br/>RAGResponse with confidence_score=0.94 > 0.6``` | ```python<br/>cache_response() called<br/>response cached for future queries``` | High-confidence response caching |
| **16. API Response** | FastAPI Serialization | ```python<br/>RAGResponse object``` | ```python<br/>QueryResponse object``` | Pydantic serialization |
| **17. HTTP Response** | FastAPI Router | ```python<br/>QueryResponse object``` | ```json<br/>HTTP 200 OK + JSON payload``` | JSON over HTTP |
| **18. Frontend Reception** | axios.then() | ```typescript<br/>HTTP response``` | ```typescript<br/>result.data: QueryResponse<br/>setResponse(result.data)``` | axios response handling |
| **19. State Update** | React useState | ```typescript<br/>QueryResponse``` | ```typescript<br/>React re-render triggered``` | React state management |
| **20. UI Rendering** | React Components | ```typescript<br/>response: QueryResponse``` | ```jsx<br/>Professional maintenance guidance UI``` | React JSX rendering |

**Key Improvements:**
- **Split Query Analysis**: 8 granular steps instead of 1 black box
- **Split Query Enhancement**: 6 detailed steps showing each technology
- **Split Vector Processing**: Separate embedding generation, normalization, search, retrieval
- **Split Scoring**: Vector, graph, and fusion scoring as separate steps
- **Split LLM Generation**: Prompt building, API call, response enhancement
- **Real Technology Exposure**: Each step shows the exact technology and method used

Now the audience can see exactly how each core technology contributes to the intelligence!