Index     779
Deep binding, 418–419
Deferred reference counting, 
299–300
Definitions
in COBOL, 60
of functions, 682–684
in subprograms, 389–391
Delegates, 420–421
delete
in associative arrays, 273
in C++, 291–293, 486
data types, 263
explicit deallocation using, 538
Delphi, 90
Denotational semantics
assignment statements in, 146
evaluation of, 147
examples of, 143–145
expressions in, 145–146
introduction to, 142–143
logical pretest loops in, 147
state of programs and, 145
Department of Defense (DoD), 
59–61, 81
Dependents, 601
Depth-first searches, 742
Dereferencing pointers, 291
Derivations, 119–121
Derived classes, 526, 540–544
Derived types, 306
Descriptors, 245
Design issues
for abstract data types, 
478–479
for array types, 260
for character string types, 250
for concurrency, 585–586
for exception handling, 633–636
for functions, 428–429
for iterative statements, 363
for multiple-selection  
statements, 354–355
for names, 205
for object-oriented  
programming, 529–534
for pointer types, 290
for subprograms, 396–397, 
413–414
trade-offs, 23
for two-way selection  
statements, 350
for union types, 285
Destructors, 487
Diamond inheritance, 531
Dictionaries, 99, 273
Dijkstra, Edsger
guarded commands by, 
376–379, 593
on PL/I, 70
semaphores by, 586
on synchronization operations, 
591
Direct left recursion, 187
Discriminated unions, 285–287
Disjoint tasks, 581
dispose, 298
DLLs (dynamic link libraries), 67, 
512
DO CONCURRENT constructs, 45
do-while statements, 
369–370
DoD (Department of Defense), 
59–61, 81
Dot notation, 278–279
Double floating-point data types, 
247
Dynabook, 86
Dynamic binding
in Ada 95, 561–562
in C#, 557–558
in C++, 544–547
introduction to, 210
in Java, 555
of method calls to methods, 
566–568
in Objective-C, 551–552
in object-oriented programming, 
527–529, 533
in Ruby, 565
in Smalltalk, 535
Dynamic chains, 450
Dynamic dispatch. see Dynamic 
binding
Dynamic languages, 68–71
Dynamic length strings, 
253–255
dynamic link libraries (DLLs), 67, 
512
Dynamic links, 446
Dynamic scoping, 227–229, 
462–466
Dynamic semantics
axiomatic semantics as. see 
Axiomatic semantics
denotational semantics as, 
142–147
introduction to, 139
operational semantics as, 
139–142
Dynamic type binding, 212–214, 
303, 569
Dynamic type checking, 303
E
Eager approach, 299
EBNF (Extended BNF), 129–132, 
181–182
ECMA (European Computer  
Manufacturers Association), 
97
Edinburgh syntax, 737
Edwards, Daniel J., 680
Eich, Brendan, 97
Elaboration, 215
Elemental operators, Fortran 95+, 
266
Elliptical references, 279
else-if clause, 360–361
Encapsulation constructs
in Ada, 482, 512, 516
in C, 510–511
in C#, 498, 512–513
in C++, 486, 511–512, 
514–515
\n780     Index
Encapsulation (continued)
introduction to, 474,  
509–510
in Java, 515–516
naming, 513–517
in Objective-C, 490–492
in Ruby, 499, 516–517
summary of, 517–518
entry clauses, 595
Enumeration constants, 255
Enumeration types
in C, 308
in C#, 102
in C++, 256, 258
designing, 255–257
evaluation of, 257–258
introduction to, 255
Environment pointers (EPs), 
442–448
Epilogue of subprogram linkage, 
443–448
EPs (Environment pointers), 
442–448
EQ? functions, 689–690, 693
Equivalence, 304–308
Erasure rule, 187
Errors
in arithmetic expressions, 332
in assignment statements, 
146–147
in recursive-descent parsers, 
183–184
European Computer Manufactur-
ers Association (ECMA), 97
EVAL, 690, 698–699
Evaluation environments, 702
Event handling
bibliographic notes on, 665
in C#, 661–664
introduction to, 630, 655–656
in Java, 656–660
summary of, 664–665
Event listeners, 657
Events, 619, 655
Exception handling
in Ada, 636–643
basic concepts of, 631–633
bibliographic notes on, 665
in C++, 643–647
design issues for, 633–636
introduction to, 16, 630–631
in Java, 647–655
summary of, 664–665
Exceptions, 332, 631
Exclusivity of objects, 529–530
Executable images, 27
expected_type, 136
Expert systems, 757–758
Explicit declarations, 211
Explicit heap-dynamic variables, 
216–218
Explicit locks, Java 5.0, 612–613, 
617
Explicit type conversions, 
331–332
Expressions
arithmetic. see Arithmetic 
expressions
assignment statements as, 
339–340
Boolean, 333–335
in denotational semantics, 
145–146
introduction to, 318
mixed-mode, 330–331
in recursive-descent parsers, 
182–185
relational, 332–333
short-circuit evaluation of, 
335–336
summary of, 341–342
unambiguous grammar for, 
125
Expressivity, 14–15
Extended accept clauses, 598
Extended ALGOL, 6
Extended BNF (EBNF), 129–132, 
181–182
eXtensible Stylesheet Language 
Transformations (XSLT), 22
extern qualifiers, 224
F
F#, 620–621, 712–715
Fact statements, 737–738
Farber, J. D., 72
Fatbars, 377
Feature multiplicity, 9
Fetch-execute cycles, 19
FGCS (Fifth Generation Computing 
Systems), 736
Fields, 277
Fifth Generation Computing  
Systems (FGCS), 736
de Figueiredo, Luis Henrique,  
100
filter, 705
final, Java, 233, 553–556
Finalization, 635
finalize methods, 553
finally clauses, 612, 652–653
Finite automata, 171
Finite mappings, 260
Firm coercion, 74
First-order predicate calculus, 
729
Fixed heap-dynamic arrays, 262
Fixed stack-dynamic arrays, 262
flex arrays, 74
float
in C, 510
in C#, 498
introduction to, 15
in type checking, 302–303
in type conversions, 329–332
Floating-point data types, 
247–248, 476
Floating-point operations, 42, 68
FLOW-MATIC, 59
FLPL (Fortran List Processing 
Language), 48
Flynn, Michael J., 578
\n Index     781
for statements
in Ada, 364
in C, 77–78
in C-based languages, 
364–366
declaration order and, 224
defined, 12
in Plankalkül, 38
in Python, 366–367
in user-located loop control 
mechanisms, 372–373
foreach statements
in array processing, 264
in C#, 102
in JSP, 106
in .NET languages, 373–374
Form, 13, 205–206
Formal parameters, 391, 394
Fortran
abstraction support in, 14
Backus designing, 20
design process for, 43
evaluation of, 45–47
evolution of, generally, 42
historical background of, 42–43
introduction to, 4–5
name forms in, 205–207
versions of, 14, 43–45, 
204–207
Fortran List Processing Language 
(FLPL), 48
Forward chaining, 741
FP (functional programming), 673
Free Software Organization, 737
Free unions, 285
Fully attributed parse trees, 134
Fully qualified references, 279
Functional compositions
introduction to, 675
operators for, 714
in Scheme, 697
Functional forms, 675–676, 
696–698
Functional programming (FP), 673
Functional programming languages
assignment statements in, 
340–341
bibliographic notes on, 721
Common LISP as, 699–701
concurrency in, 618–621
F# as, 712–715
functional forms in,  
675–676
fundamentals of, 676–677
Haskell as, 707–712
imperative languages  
supporting, 715–717
imperative languages vs., 
717–719
introduction to, 672–673
LISP as, 677–680
mathematical functions in, 
673–676
ML as, 701–707
Scheme as. see Scheme
simple functions in, 674–675
summary of, 720–721
Functions
design issues for, 428–429
in Scheme, 691–694
side effects of, 428–429
as subprograms, 395–396
Functors, 729
future constructs, 618
G
GAMM (German Society for 
Applied Mathematics and 
Mechanics), 53
Garbage collection, 299–302
Gates, Bill, 66
Genealogy of languages, 37
General Purpose Simulation  
System (GPSS), 22
Generality, 18
Generate and test, 753
Generation, 116–117
Generators, 709
Generic subprograms
in C# 2005, 427
in C++, 423–425
in F#, 427–428
introduction to, 397,  
422–423
in Java 5.0, 425–426
German Society for Applied 
Mathematics and Mechanics 
(GAMM), 53
getPriority methods, 606
Getter methods, 564
Glennie, Alick E., 42–43
Global scope, 224–227
GNOME, 31
Go, 91
Goals, 739–740
Google, 91
Gosling, James, 92
goto, 195–197
GPSS (General Purpose  
Simulation System), 22
Grammars
ambiguous, 122–123
attribute. see Attribute 
grammars
context-free, 117–118
derivations and, 119–121
LL grammar class,  
187–190
recognizers and, 132
unambiguous, 125–129
van Wijngaarden, 74
Graphical user interfaces (GUIs). 
see GUIs (graphical user 
interfaces)
Griesemer, Robert, 91
Griswold, R.E., 72
Guarded commands, 376–379, 593
Guards, 586
GUIs (graphical user interfaces)
defined, 655
in Delphi, 90
UNIX and, 31
\n782     Index
H
Hammond, P., 758
Handles, 191–192
Harbison, Samuel P., 356
Hashes, 272–273, 276
introduction to, 96
Haskell, 707–712
Headed horn clauses, 734
Header files, 510–511
Headless horn clauses, 734
Heap-dynamic arrays, 263
Heap-dynamic variables, 290
Heaps, 289
Heavyweight tasks, 581
Hejlsberg, Anders, 90, 101
Hidden concurrency, 579
Higher-order functions, 675
High-Order Language Working 
Group (HOLWG), 81
High-Performance Fortran (HPF), 
621–623
Hoare, C.A.R.
on Ada, 83
on language design, 14, 23
message passing by, 593–594
on monitors, 591
Pascal by, 75
HOLWG (High-Order Language 
Working Group), 81
Hopper, Grace
award in name of, 480, 536
compiling systems by, 41
on programming languages, 59
Horn clauses, 734
HPF (High-Performance Fortran), 
621–623
HTML (HyperText Markup 
Language)
introduction to, 7, 22
JavaScript and, 97–98
JSP and, 105
PHP and, 99
XML and, 104
Hursley Laboratory, 69
Hybrid implementation systems, 
29–30
HyperText Markup Language 
(HTML). see HTML 
(HyperText Markup 
Language)
Hypotheses, 734
I
IAL (International Algorithmic 
Language), 54
IBM
APL developed by, 71
Fortran developed by, 42–47
orthogonality and, 10
PL/I developed by, 68, 73–74
PL/S developed by, 6
UNIVAC ”compiling” system 
and, 41
“The IBM Mathematical  
FORmula TRANslating  
System: FORTRAN,” 43
id type, 551–552
Identifiers, 115, 204
Identity operators, 320
IEEE Floating-Point Standard, 
247–248
Ierusalimschy, Roberto, 100, 
274–275
If logical constructs, 45
IF selector functions, 685–686
if statements
assignments and, 340
in compound statements,  
351
in Extended BNF, 130
in JSP, 105–106
in multiple-selection  
statements, 360–362
in nesting selectors, 351–354
in recursive-descent parsers, 
181–186
rules for, 119
in selector expressions, 354
IFIP (International Federation of 
Information Processing), 75
if-then-else statements, 
128–129, 325
Imperative programming 
languages
functional languages  
supporting, 715–717
functional languages vs., 
717–719
introduction to, 18
object-oriented hybrid  
languages and. see C++
Implementation methods
compiler implementation, 
24–28
hybrid implementation systems, 
29–30
preprocessors in, 30
for protocols, 551
pure interpretation, 28
for subprograms. see 
Subprograms, 
implementing
understanding of, 4
Implicit declarations, 211
Implicit heap-dynamic arrays, 74
Implicit heap-dynamic variables, 
218
Implicit locks, 612–613
import declarations, 515–516
In mode parameter passing, 400
in operators, 266
include statements, 565
Incremental mark-sweep garbage 
collection, 301
Indicants, 74
Indices, 260–262
Inference rules
evaluation of, 160–161
in logical pretest loops, 
154–158
in program proofs, 158–160
as rule of consequence, 152
\n Index     783
in selection statements, 
153–154
in sequences, 152–153
weakest preconditions and, 
149–150
Inferencing process, 740–743
Infix operators, 319
Information hiding
in Ada, 482–483
in C#, 498–499
in C++, 486
in Objective-C, 492–493
in Ruby, 499
Inheritance
in Ada, 559–560
in C#, 557
in C++, 539–544
introduction to, 525–527
in Java, 553–555
in Objective-C, 549–551
in Ruby, 565
in Smalltalk, 534–535
Inherited attributes, 134
Initial values, 363
Initialization, 234, 533–534
Inner classes, 555–556
Inout mode parameter passing, 
400
Instance data storage, 566
Instance methods, 527
Instance variables, 527
Instantiation, 733, 737
int
abstract data types,  
497–498
in C, 326
in C++, 295
in Java, 609–611
in ML, 702–704
in nonblocking synchronized 
access, 612
in type checking, 302–303
in type conversions, 329–332
unary minus operator and, 320
integer
data types, 246–247
ordinal types, 255
reserved words, 206–207
Interface abstract class, 553–555
Interlocked classes, 616
International Algorithmic  
Language (IAL), 54
International Federation of Infor-
mation Processing (IFIP), 75
International Standards  
Organization (ISO), 97, 249
Interpreter, 678–681
intrinsic attributes, 134–135
Intrinsic condition queues, 608
Intrinsic limitations, 756
iPhones, 90
IPL (Information Processing  
Language), 47–49
is operators, 266
ISO (International Standards 
Organization), 97, 249
Iterative statements
counter-controlled loops and, 
363, 367–368
data structures for, 371–375
design issues for, 363
introduction to, 362–363
logically controlled loops and, 
368–370
for statements, 364–367
user-located loop controls as, 
370–371
Iverson, Kenneth P., 71
J
Jacopini, Giuseppe, 350, 379
Jagged arrays, 267–268
JARs (Java Archives), 513
Java
abstract data types in, 
496–497, 506–509
assertions in, 653–654
classes of exceptions in, 647
concurrency in, 21
design process for, 91–92
dynamic binding in, 555
evaluation of, 93–94
event handling in, 656–660
exception handling in, 16, 
647–655
expressivity in, 15
feature multiplicity in, 9
finally clause in, 652–653
imperative-based  
object-orientation of, 91
inheritance in, 553–555
introduction to, 12
JIT systems in, 30
nested classes in, 555–556
object-oriented programming 
in, 552–556
overview of, 91–94
packages in, 515–516
parameterized abstract data 
types in, 506–509
popularity of, 3
Swing GUI components in, 
656–657
threads in. see Threads
Java Archives (JARs), 513
Java Server Pages Standard Tag 
Library (JSTL), 22, 105–106
JavaScript
anonymous functions in, 
715–716
arrays in, 264
dynamic type binding in, 
213–214
event handling in, 656
evolution of, 97–98
execution speed in, 718
implicit heap-dynamic  
variables in, 218
lambda expressions in, 716
Lua vs., 101
nested functions in, 220–221
nested subprograms in, 454
\n784     Index
PHP vs., 99
pure interpretation in, 28
relational operators in, 333
JIT (Just-in-Time). see Just-in-
Time ( JIT) compilers
Jobs, Steve, 90
join methods, 604–606
JOVIAL, 55
JSP, 105–106
JSTL (Java Server Pages Standard 
Tag Library), 22, 105–106
Just-in-Time ( JIT) compilers, 30
K
Kay, Alan, 85–86
Kemeny, John, 63–64
Kernighan, Brian, 95, 376
Keys, 272
Keyword parameters, 392
Keywords, 206
Knuth, Donald, 133, 193–194
Korn, David, 95
Kowalski, Robert
on logic-based semantic  
networks, 758
Prolog by, 79, 736
ksh scripting language, 95
Kurtz, Thomas, 63
L
Lambda calculus, 675
Lambda expressions
introduction to, 675
in JavaScript, 716
in ML, 705
in Scheme, 682, 695
Language design
for Ada, 81–82
for ALGOL 58, 53–54
for ALGOL 60, 55–56
for ALGOL 68, 73
for BASIC, 63–64
for C#, 101–102
for C++, 88–89
categories in, 21–23
for COBOL, 59–60
computer architecture in, 
18–20
evaluation criteria for, 7–18
for Fortran, 43
influences, 18–21
for Java, 91–92
for LISP, 48
methodologies for, 20–21
for PL/I, 69
for Prolog, 79
for SIMULA 67, 72–73
for Smalltalk, 85–86
syntax in, 12–13
trade-offs, 23
Language generators, 116–117
Language recognizers, 116
Language selection, 3
Laning and Zierler system, 43, 53
last statements, 371
Lazy approach, 299
Lazy evaluation, 710–712
LCF (Logic for Computable  
Functions), 52
Learning new languages, 3–4
Left factoring, 189–190
Left recursive grammar rules, 128
Left-hand side (LHS)
in bottom-up parsers, 180, 191
in denotational semantics, 144
fundamentals of, 118–123
grammar rules for, 128
in LL parsers, 187–190
in LR parsing, 195
Leftmost derivations, 120–121
Lerdorf, Rasmus, 98
let
in declaration order, 221–223
in F#, 712–715
in ML, 281
Level numbers, 277
Lexemes, 115–116, 170–177
Lexical analysis
introduction to, 25–26, 
168–169
overview of, 169–177
parsing in. see Parsing
summary of, 197–199
Lexical scoping, 219
Lifetime, 214–215, 229–230
Lightweight tasks, 581
Limited dynamic length strings, 
253–255
Limited private types, 483
Linkers, 27, 444
Linking, 27
Linking and loading, 27
LISP
arithmetic expressions in, 324
artificial intelligence and, 47–48
Common, 51–52
data structures in, 49, 
677–678
data types in, 677–678
descendants of, 51
design process for, 48
evaluation of, 50–51
functional programming in, 
47–50, 677
interpreter in, 678–680
introduction to, 6
languages related to, 52
list processing and, 47–48
orthogonality in, 11
overview of, 49
Scheme and, 51
syntax of, 50
List comprehensions, 283
List functions, Scheme, 282–283
Lists
descriptions of, 119
functions of, 686–690
processing, 47–48
simple, 678, 691–692
structures of, 49–50, 746–751
types of, 281–284
Liveness, 585
LL algorithms, 179
LL grammar class, 187–190
Load modules, 27
\n Index     785
Loaders, 444
Local nested classes, 556
Local referencing environments, 
397–399
Local variables, 218, 397–399
local_offset, 450
Locks, 612–613, 616–617
Locks-and-keys approach, 298
Logic for Computable Functions 
(LCF), 52
Logic programming languages
applications of, 757–758
bibliographic notes on, 759
clausal form in, 731–732
defined, 728
expert systems and, 757–758
introduction to, 22, 728
overview of, 734–736
predicate calculus for, 
728–734
problem set on, 760–761
programming exercises on,  
761
Prolog. see Prolog
propositions in, 729–731
relational database  
management systems  
and, 757
summary of, 758–759
theorem-proving in, 732–734
Logical concurrency, 579
Logical pretest loops, 147, 
154–158
Logically controlled loops, 
368–370
long primitive type variables, 612
Loop invariants, 154–158
Loop parameters, 363
Loop variables, 363–364
Loops
counter-controlled, 363–368
defined, 362
logical pretest, 147, 154–158
logically controlled, 368–370
user-located, 370–371
Lost heap-dynamic variables, 293
Love, Tim, 90
LR parsers, 190, 193–197
Lua
anonymous functions in, 390
arrays in, 264, 272, 276
enumeration types in, 257
evolution of, 37, 100–101
global variables in, 399
Ierusalimschy on, 274–275
multiple assignments in, 340
nested subprograms in, 454
parameters in, 393–395
records in, 278
relational operators in, 333
selection statements in, 353
tables in, 276
L-value, 208–209
M
MAC OS X, 90
Mark-sweep garbage collection, 
299–302
Markup languages, defined, 22
Markup/programming hybrid  
languages, 104–106
Massachusetts Institute of 
Technology (MIT). see MIT 
(Massachusetts Institute of 
Technology)
match expressions, 288, 362
Matching subgoals, 740
Matching type parameters, 644
Mathematical functions,  
673–676
Matsumoto, Yukihiro, 100
Mauchly, John, 40
McCabe, F. G., 737
McCarthy, John, 48, 677–680
McCracken, Daniel, 23
Meek coercion, 74
Mellish, C. S., 753
Member functions, 486, 539
Memory cells, 209
Memory leakage, 293
Message interfaces, 526
Message protocols, 526
Messages
binding dynamically. see 
Dynamic binding
in object-oriented  
programming, 525–527
passing, 593–594
MetaLanguage (ML), 52, 
701–707
Metalanguages, 118
Metasymbols, 130
Method calls, 566–568
Methods, 526–527, 566–568
Microsoft
C# by, 101
JScript.NET by, 97
.NET computing platform by, 89
Visual BASIC by, 66–67
Visual Studio .NET by, 31
Milner, Robin, 52
MIL-STD 1815, 82
MIMD (Multiple-Instruction 
 Multiple-Data) computers, 578
Minsky, Marvin, 48
Miranda, 52
MIT (Massachusetts Institute of 
Technology)
AI Project at, 48
LISP at, 677
Scheme at, 51, 681
Mixed-mode assignment  
statements, 341
Mixed-mode expressions, 
330–331
Mixins, 550
ML (MetaLanguage), 52, 
701–707
M-notation, 678, 690
Modules, 516–517
Monitors, 591–593
MSDOS.exe, 66–67
Multicast delegates, 421
Multilisp, 618
Multiparadigm programming, 536
\n786     Index
Multiple assignment statements, 
340
Multiple inheritance, 527, 531–532
Multiple-Instruction Multiple- 
Data (MIMD) computers, 
578
Multiple-selection statements
design issues for, 354–355
examples of, 355–358
implementation of, 358–359
using if, 360–362
Multiprocessors, 577–579
Multithreaded programs, 579–580
N
Name type equivalence, 305
Named constants, 232–234
Names
design issues for, 205
in encapsulation constructs, 
513–517
form of, 205–206
introduction to, 204–205
keywords, 206
reserved words and, 206–207
special words, 206–207
summary of, 234–235
of variables, 208
variables vs., 207–209
Narrowing type conversions, 329
National Physical Laboratory, 69
Natural operational semantics, 140
Naur, Peter, 55–56, 117
NCC (Norwegian Computing 
Center), 72
Negation problem, Prolog, 
754–756
Nested classes
in C#, 558
in Java, 555–556
in object-oriented  
programming, 533
Nested list structures, 49
Nested subprograms, 397–399, 
454–460
Nesting classes, 533
Nesting selectors, 351–354
nesting_depth, 455
.NET languages
assemblies in, 512–513
computing platform for, 89
evolution of, 101
F# as, 712
introduction to, 22
JIT systems in, 30
JScript.NET as, 97
Microsoft Visual Studio .NET 
as, 31
programming environments 
of, 31
NetBeans, 31
Netscape, 97
von Neumann, John, 18
von Neumann architecture
in imperative programming 
languages, 204
introduction to, 18–19
in LR parsing, 195
von Neumann bottlenecks, 27
new
in allocation of objects, 532
in C#, 498, 557
in C++, 486
data types, 263
in heap management, 298
in Java, 552
in Ruby, 564
New Programming Language 
(NPL), 69
Newell, Allen, 47
NeXT, 90
next iterators, 373
Nil values, 49, 289
Nonblocking synchronization, 612
Nonconverting cast conversions, 
304
nonlocal, 227
Nonstrict programming languages, 
710
Nonterminal symbols, 118, 122
Norwegian Computing Center 
(NCC), 72
NOT operators, 333–334
not operators, 755–756
NPL (New Programming  
Language), 69
NULL, 691–692
Numeric data types, 246–249
Numeric predicate functions, 685
Nygaard, Kristen, 72–73
O
Object slicing, 532–533
Objective-C
abstract data types in, 
490–496
C++ and, 90
dynamic binding in, 551–552
encapsulation constructs in, 
490–492
information hiding in, 492–493
object-oriented programming 
in, 549–552
Object-oriented constructs, 566–568
Object-oriented languages
allocation of objects in, 
532–533
deallocation of objects in, 
532–533
design issues for, 529–534
dynamic binding in, 533
exclusivity of objects in, 
529–530
initialization of objects in, 
533–534
multiple inheritance in, 
531–532
nested classes in, 533
single inheritance in, 531–532
subclasses vs. subtypes in, 
530–531
Object-oriented programming
in Ada, 558–563
binding method calls to  
methods in, 566–568
\n Index     787
in C#, 556–558
in C++, generally, 538–539, 
547–549
in C++ dynamic binding, 
544–547
in C++ inheritance, 539–544
child packages in, 562
dynamic binding in, 527–529
inheritance in, 525–527
instance data storage in, 566
introduction to, 21
in Java, 552–556
in Objective-C, 549–552
in Ruby, 563–565
in Smalltalk, 85–87, 534–538
Stroustrup on, 536
summary of, 569–570
support for, generally,  
524–525
Objects
in abstract data types, 475
defined, 245–246
exclusivity of, 529–530
initialization of, 533–534
in object-oriented program-
ming, generally, 525–526
OCaml, 52
Operand evaluation order, 
325–328
Operational semantics
evaluation of, 142
introduction to, 139–140
process of, 140
Operator evaluation order, 
319–325
Operator overloading, 9, 328–329
Operator precedence, 123–126
Operator precedence rules, 320
Optimization, 17
or else statements, 336
OR operators, 333–336
Ordinal data types
enumeration types, 255–258
implementation of, 259
integer, 255
introduction to, 125–129, 255
subrange, 258–259
Orthogonality, 9–12, 73
others, 265, 637
otherwise, 708, 711
Out mode parameter passing, 400
Output functions, 684
Overflow, 332
Overloaded literals, 256–257
Overloaded operators, 328–329
Overloaded subprograms, 397, 
421–422
Overridden methods, 526–527
override commands, 557–558
P
Package scope, 515
Package specification, 482–484
Packages, 482–485, 562
Pairwise disjointness test, 188
Papert, Seymour, 86
Paradigms of programming, 
536–537
Parameter profiles, 390
Parameterized abstract data types
in Ada, 503–504
in C# 2005, 509
in C++, 505–506
introduction to, 503–509
in Java, 506–509
Parameter-passing methods
of common languages, 
406–408
examples of, 414–417
implementation models for, 
400–405
implementation of, 405–406
introduction to, 399–400
semantic models of, 400
Parameters
in multidimensional arrays, 
410–413
for subprograms, 391–395
subprograms as, 417–419
Parametric polymorphism, 423
params, 393
Parent classes, 526–527
Parentheses, 323–324
Parse trees, 25, 121–122
Parsing
bottom-up, 180, 190–192
complexity of, 180–181
introduction to, 177–178
LL grammar class in, 
187–190
LR parsers for, 193–197
problem set on, 200–201
programming exercises  
on, 201
recursive-descent, 181–187
review questions on,  
199–200
shift-reduce algorithms for, 
192–193
summary of, 197–199
top-down, 179
Partial correctness, 158
Partial evaluation, 706
Pascal
Concurrent, 591
dispose operator in, 293
enumeration data types in,  
256
evolution of, 36–37, 57, 
75–77
lock-and-keys approach  
in, 298
nested subprograms in, 399
parameter-passing in, 419
run-time checks in, 312
subrange types in, 258
Turbo, 101
Pass-by-assignment, 408
Pass-by-copy, 403
Pass-by-name, 404–405
Pass-by-reference, 403–404
Pass-by-result, 401–403
Pass-by-value-result, 403
Passedby value, 401
pcall constructs, 618
\n788     Index
PDA (Pushdown automaton), 
193
Perl
arrays in, 261–264
assignments in, 337–341
associative arrays in, 272–276
binary logic operators in, 334
C# vs., 103
dynamic length strings in, 253
dynamic scoping in, 227–228
evolution of, 36–37
exponentiation in, 396
foreach statements in, 380
hybrid system implementing, 
30
as imperative programming 
language, 22
overview of, 95–97
parameter passing in, 407
pattern matching in, 170, 252
prefix operators in, 319
Python vs., 99–100
Ruby vs., 100
slices in, 268
then and else clauses in, 350, 
352
Unicode in, 249
variables in, 205, 211
Perlis, Alan, 46, 53
PHP
arrays in, 273, 276, 373
execution speed in, 718
foreach statements in, 103
global variables in, 224–225
overview of, 98–99
parameter passing in, 392, 407
pattern matching in, 252
pure interpretation in, 28
relational operators in, 333
as scripting language, 7, 28
switch statements in, 357
type binding in, 213
variable names in, 205
Phrases, 191–192
Physical concurrency, 579
Pike, Rob, 91
pipeline (|>) operators, 714
Plankalkül, 38–39
PL/I
design process for, 69
evaluation of, 70–71
historical background of, 68
introduction to, 68
language overview of, 69–70
operational semantics in, 142
overview of, 68–71
PL/S, 6
Pointer types
in Ada, 293
in C and C++, 294–295
dangling, 292–293, 297–298
design issues for, 290
evaluation of, 297
heap management and, 
298–302
introduction to, 289–290
lost heap-dynamic variables 
in, 293
operations in, 290–291
problems in, 291
representations of, 297
Polonsky, I. P., 72
Polymorphic references, 528
Polymorphic subprograms, 
422–423
Polymorphism, 422–423
Pontifical University of Rio de 
Janeiro, 100, 274
Portability, 18
Portable systems languages. see C
Positional parameters, 392
Postconditions
in assignment statements, 
150–152
introduction to, 148–149
in logical pretest loops, 
154–158
in program proofs, 158–160
in selection statements, 
153–154
in sequences, 152–153
weakest preconditions  
and. see Weakest 
preconditions
Posttest, 363
pragma, 601, 640
Precedence, 319–321
Precision, 247
Preconditions
in assignment statements, 
150–152
introduction to, 148–149
in logical pretest loops, 
154–158
in program proofs, 158–160
in selection statements, 
153–154
in sequences, 152–153
weakest. see Weakest 
preconditions
Predicate calculus
defined, 729
for logic programming  
languages, 728–734
in Prolog, 79
Predicate functions, 134, 
689–691
Predicate transformers, 
154–158
Prefix operators, 319
Preprocessors, 30
Pretest, 362
Primitive data types
boolean, 249
character, 249–250
complex, 248
decimal, 248–249
floating point, 247–248
integer, 246–247
numeric, 246–249
Primitive numeric functions, 
681–682