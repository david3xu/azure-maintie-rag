Index     789
Priorities of tasks, 601–602
Priorities of threads, 606–607
private
in Ada, 562
in C#, 498–499
in C++, 486–487, 540–544
in Ruby, 500–501
Private types, 482–484
Procedure-oriented programming,
21
Procedures, 395–396
Process abstraction, 475
Processes, 581
Producer-consumer problems,
582
Productions, 118
Program calculus, 38
Program counters, 19
Program proofs, 158–160
Program_Error exceptions,
639
Programming design methodolo-
gies, 20–21
Programming domains
artificial intelligence in, 6
business applications in, 5–6
generally, 5
scientific applications in, 5
in systems programming, 6–7
Web software and, 7
Programming environments, 31
Prolog
arithmetic in, 743–746
closed-world assumption in, 754
deficiencies of, 751–756
design process for, 79
elements of, generally,
736–737
evaluation of, 80
fact statements in, 737–738
goal statements in, 739–740
inferencing process of, 740–743
intrinsic limitations in, 756
introduction to, 6
language overview of, 79–80
list structures in, 746–751
logic in, generally, 79
negation problem in, 754–756
origins of, 736
resolution order control in,
751–753
rule statements in, 738–739
terms in, 737
Prolog++, 21
Prologue of subprogram linkage,
443–448
Properties, C#, 498–499
Propositions, 729–731
protected access modifiers, 498
Protected objects, 592, 602–603
Protocols, 390, 551
Prototypes, 391
Pseudocodes
introduction to, 39–40
related work, 42
Short Code, 40–41
Speedcoding, 41
UNIVAC ”compiling” system,
41
public
in C#, 498
in C++, 486
derivations, 540–544
in Ruby, 500–501
Pure interpretation, 28
Pure virtual functions, 546
Pure virtual method, 529
Pushdown automaton (PDA), 193
Python
arrays in, 264–268
complex values in, 248
concurrency in, 585
def statements in, 390
dictionaries in, 273
elif statements in, 360
interpreting expressions in, 681
lambda expressions in, 716
long integer type of, 246
mutable lists in, 283–284, 311
nested subprograms in, 219,
454, 510
overview of, 99–100
parameters in, 392–394
pass-by-assignments in, 408
pattern matching in, 252
referencing environments and,
230
strings in, 251
subprograms in, 389
then and else clauses in, 351
tuples in, 280–281, 712
type binding in, 213
Unicode in, 249–250
Q
Quantifiers, 730
Quasi-concurrency, 433
Quasi-concurrent subprograms,
579–580
Queries, 739–740
QUOTE, 686–687
R
Race conditions, 582
Radio buttons
in C#, 661–664
in Java, 656–660
raise statements, 640
Raised exceptions, 631
RAND Corporation, 47
Range
for arrays, 284
in floating-point data types,
247
iterators, 372
in Python, 367
Raw methods, 425
RDBMSs (Relational database
management systems), 757
Read statements, 630
Readability, 8, 16
Reader macros, 701
\n790     Index
Readers, 701
read-evaluate-print loops (REPLs),
681
readonly constants, 233–234
Ready tasks, 583
Real types, 703
Recognition, 116
Record types
definition of records in,
277–278
evaluation of, 279
implementation of, 279–280
introduction to, 276–277
references to fields in, 278–279
Rectangular arrays, 267–268
Recursion, 449–453
Recursive rules, 119
Recursive-descent parsers
LL grammar class in,
187–190
overview of, 181–187
as pushdown automatons,
193
ref type, F#, 620
Reference counters, 299
Reference parameters, 406
Reference types
dangling pointers and,
297–298
heap management and,
298–302
implementation of, 297
introduction to, 289–290
overview of, 295–297
representations of, 297
Referencing environments,
230–232
Referential transparency,
327–328, 676–677
Refutation complete, 733
Regular expressions, 252
Regular grammars, 117
Regular languages, 171
Relational data types, 332–333
Relational database management
systems (RDBMSs), 757
Relational expressions, 332–333
Relational operators, 332–335
Reliability, 15
Rendezvous, 594–597
repeat, 19
REPLs (read-evaluate-print loops),
681
Report Program Generator (RPG),
22
Reserved words, 206–207
reset, 373
Resolution
arithmetic computation for,
743–746
closed-world assumption in,
754
defined, 732
list structures for, 746–751
order control, 751–753
in Prolog, 740–743, 751–753
Resumes, 433–434
Resumption, 634
Returned values, 429
Returns, 442
reverse functions, 364, 750
Richards, Martin, 77
Right recursive grammar rules,
128
Right-hand side (RHS)
in bottom-up parsers, 180, 191
in denotational semantics,
143–144
derivations and, 121
in Extended BNF, 130–132
fundamentals of, 118–123
grammar rules for, 128
in LL parsers, 187–190
in LR parsing, 195
in recursive-descent parsers,
182–184
in top-down parsers, 179
Ritchie, Dennis, 77–78, 91, 376
Romanovsky, Alexander, 643
van Rossum, Guido, 99
Roussel, Phillippe, 79, 736
Row major order, 270
RPG (Report Program
Generator), 22
Ruby
abstract data types in,
499–503
arithmetic expressions in, 324
dynamic binding in, 565
evolution of, 67, 100
inheritance in, 565
modules in, 516–517
object-oriented programming
in, 563–565
Rule of consequence, 152
Rules, 118–119, 739–740
run methods, 603–604
Running tasks, 584
Run-time stacks, 447
Russell, Stephen B., 680
R-value, 209
S
Sandén, Bo, 643
Satisfying subgoals, 740
Scalable algorithms, 577
Schedulers, 583
Scheme
apply-to-all functional forms
in, 697–698
code-building functions in,
698–699
control flow in, 685–686
defining functions in,
682–684
example of, 691–694
functional compositions in,
697
functional forms in, 696–698
as functional language, 681
interpreter in, 681
LET, 694–695
\n Index     791
LISP, 51
list functions in, 686–689
numeric predicate functions
in, 685
origins of, 681
output functions in, 684
predicate functions in, 689–691
primitive numeric functions in,
681–682
symbolic atoms and lists in,
689–691
tail recursive functions in,
695–696
Schwartz, Jules I., 55
Scientific applications, 5
Scope
blocks for, 220–223
declaration order for, 223–224
dynamic scoping, 227–229
global, 224–227
introduction to, 204
lifetime and, 229–230
named constants and,
232–234
overview of, 218
referencing environments and,
230–232
static scoping, 219–220, 227
summary of, 234–235
Scott, Dana, 147
Scripting languages, 95–101
Scripts, 95
select statements, 597–599
Selection, 153–154
Selection statements
counter-controlled loops, 363
introduction to, 350
multiple-selection, 354–362
two-way, 350–354
Selector expressions, 354
Semantic domains, 142
Semantics
axiomatic. see Axiomatic
semantics
bibliographic notes on,
161–162
denotational. see Denotational
semantics
dynamic, 139
introduction to, 113–115
natural operational, 140
operational, 139–142
static, 133
structural operational, 140
of subprogram calls and
returns, 442
summary of, 161
syntax and. see Syntax
Semaphores, 586–590, 607
Sentences, 115
Sentential forms, 120
Sequences, 152–153
Sergot, M. J., 758
Server tasks, 596
Servlet containers, 105
Setter methods, 564
S-expressions, 680
Shallow access, 464–466
Shallow binding, 418–419
SHARE, 53–55, 68–69
Shared inheritance, 531
Shaw, J. C., 47
Shift-reduce algorithms, 192–193
Short Code, 40–41
short operands, 320, 331
Short Range Committee, 60
Short-circuit evaluation, 335–336
Side effects, 325–328, 428–429
SIGPLAN Notices, 82
SIMD (Single-Instruction
 Multiple-Data) computers, 578
Simon, Herbert, 47
Simple assignment statements,
336–337
Simple functions, 674–675
Simple lists, 678, 691–692
Simple phrases, 191–192
Simplicity, 8–9, 13–14
SIMULA 67
data abstraction in, 72
design process for, 72–73
introduction to, 21
language overview of, 73
object-oriented programming
in, 525
Single inheritance, 527,
531–532
Single-Instruction Multiple-Data
(SIMD) computers, 578
Single-size cells, 299
sleep methods, 605
Slices, 250, 268–269
Smalltalk
design process for, 85–86
dynamic binding in, 535
evaluation of, 87
inheritance in, 534–535
introduction to, 21
language overview of, 86–87
object-oriented programming
in, 85, 525, 534–538
SNOBOL, 71–72
Solaris Common Desktop
Environment (CDE), 31
Source languages, 25
special, 52
Special words, 12, 206–207
Speedcoding, 41
SQL (Structured Query Language),
757
Stack-dynamic arrays, 56, 262
Stack-dynamic local variables,
445–453
Stack-dynamic variables,
215–216
Stanford University, 75
start methods, 604
Start symbols, 119
State diagrams, 171
State of programs, 145
Statement-level concurrency,
621–623
\n792     Index
Statement-level control structures
conclusions about, 379–380
counter-controlled loops,
367–368
guarded commands, 376–379
introduction to, 2–3, 347–349
iterative statements, 362–363,
371–375
logically controlled loops,
368–370
selection statements, 350
for statements, 364–367
summary of, 380
two-way selection statements,
350–354
unconditional branch
statements, 375–376
Static ancestors, 219
Static arrays, 262
Static binding, 210, 533
Static chaining, 454–460
Static length strings, 252–255
Static links, 454–455
static modifiers, 263
Static parents, 219
Static scoping
evaluation of, 227
overview of, 219–220
pointers in, 455
Static semantics, 133
Static type bindings, 211–212
Static variables
in binding, 215
in dynamic scoping, 229
introduction to, 13
in nested subprograms, 398
static_depth, 455
Steele Jr., Guy L., 356
Steelman requirements document,
82
Stepsize, 363
Stichting Mathematisch Centrum,
99
Storage bindings, 214–215
Storage_Error exceptions, 639
Strachey, Christopher, 147
Strawman requirements document,
81–82
Strict programming languages,
710
Strong typing, 303–304
Stroustrup, Bjarne
on C++, 480–481
C++ by, 88
on programming paradigms,
536–537
structs
in C, 308, 310
in C#, 102
in C-based languages, 38
data type, 277
introduction to, 11
Structural operational semantics,
140
Structure type equivalence, 305
Structured Query Language (SQL),
757
Structures, 737
Subclasses, 526, 530–531
Subgoals, 740
Subprogram calls, 389
Subprogram definitions, 389
Subprogram headers, 389
Subprogram linkage, 442
Subprogram-level concurrency,
581–586
Subprograms
in C# 2005, 427
in C++, 423–425
calling indirectly, 419–421
characteristics of, 388–389
closures, 430–432
coroutines, 432–435
definitions in, 389–391
design issues for, 396–397,
413–414
in F#, 427–428
functions as, 395–396,
428–429
fundamentals of, 388
generic, 422–428
implementation of. see
Subprograms,
implementing
introduction to, 388
in Java 5.0, 425–426
local referencing environments
for, 397–399
local variables in, 397–399
multidimensional arrays and,
410–413
nested, 397–399
overloaded, 421–422
parameter-passing in. see
Parameter-passing
methods
parameters as, 417–419
parameters for, 391–395
problem set on, 438–439
procedures as, 395–396
returned values and, 429
side effects of functions in,
428–429
summary of, 435–436
type checking parameters,
408–410
user-defined overloaded data
types in, 430
Subprograms, implementing
blocks in, 460–462
calls in, 442
deep access in, 462–464
dynamic scoping in,
462–466
introduction to, 442
of nested subprograms,
454–460
with recursion, 451–453
returns in, 442
shallow access in, 464–466
of simple subprograms,
443–445
stack-dynamic local variables
for, 445–453
static chaining for, 454–460
\n Index     793
summary of, 466
without recursion, 449–451
Subrange types
designing, 258–259
evaluation of, 259
introduction to, 258
Subscript bindings, 262–264
Subscripts, 258
Substring references, 250
subtype enumeration type, 258
Subtype polymorphism, 422
Subtypes, 306, 530–531
Sun Microsystems, 92
super
in Java, 553
in Objective-C, 550
pseudovariables, 535
in Ruby, 564
Superclasses, 526
Suppress pragma, 640
Swing GUI components, 656–657
switch
in C, 77–78
in C#, 376
multiple-selection statements
and, 355–358
Symbolic atoms and lists,
689–691
Symbolic logic, 729
Synchronization
in Ada, 599–601
in concurrency, 586–592
introduction to, 581–585
in Java, 607–608
of modifiers, 93, 592
nonblocking, 612
of statements, 608
of threads, 616–617
Synchronous message passing,
593–594
Syntactic domains, 142
Syntax
ambiguous grammars in,
122–123
analysis of, 25–27, 168–169
associativity in, 126–128
attribute grammars and. see
Attribute grammars
bibliographic notes on,
161–162
BNF and, 117–118
context-free grammars and,
117–118
derivations in, 119–121
design of, 12–13
in Extended BNF, 129–132
fundamentals of, 118–119
generation of, 116–117
grammars and, 117–121, 132
if-then-else statements,
128–129
introduction to, 113–115
issues in describing, 115–117
of LISP, 50
list descriptions in, 119
methods of describing, 117
operator precedence in,
123–126
parsing and. see Parsing
recognition of, 116
recognizers in, 132
semantics and. see Semantics
summary of, 161, 197–199
unambiguous grammars in,
128–129
Synthesized attributes, 134
Syracuse University, 732
System.Object, 102
Systems programming, 6–7
Systems software, 6
T
Tagged types, 559–561
Tail recursive functions,
695–696
Task descriptors, 586
Task ready queues, 584
task specifications, 594–595
Task termination, 601
Tasking_Error exceptions, 639
Tasks, 581–585
Template functions, 423
Terminal symbols, 118, 122
Terminal values, 363
terminate, 599, 601
Terms, 737
Ternary operators, 319
Tests, 709
Texas A&M University, 480, 536
Text boxes, 656
then, 128–129, 350
Theorem-proving, 732–734
Theory of data types, 308–310
Thompson, Ken, 91
Threads
in C++, 544
in competition synchronization,
607–608
concurrency in, 603–604, 613
in cooperation synchronization,
608–611
defined, 581
explicit locks in, 612–613
in Java, 93, 606–607
in nonblocking synchronization,
612
priorities of, 606–607
semaphores in, 607
Thread class, 604–606
Threads of control, 579–580
throw statements, 644–651
Thrown exceptions, 631
throws clauses, 654
Tokens, 115, 170–177
Tombstones, 297–298
Top-down parsers, 179
Top-down resolution, 741
Total correctness, 158
Tracing models, 744–745
Trimming, 74
Tripod, 66–67
try blocks, 612, 614
try clauses
in C++, 643–646
in Java, 648–653
\n794     Index
Tuples, 280–281
Turing machines, 678
Turner, David, 52
twos complement, 247
Two-way selection statements
clause forms in, 350–351
control expressions for, 350
design issues for, 350
nesting selectors in, 351–354
selector expressions in, 354
type
in Ada enumeration types, 258
in Ada equivalence, 306–307
in Ada union types, 286, 289
in F#, 287
in ML, 281
Type, defined, 209
Type bindings
dynamic, 212–214
introduction to, 210
static, 211–212
Type checking
introduction to, 15
overview of, 302–303
parameters in, 408–410
Type conversions, 329–332
type enumeration type, 257, 261
Type equivalence, 304–308
Type errors, 303
Type inference, 211
typedef, 308
U
Unambiguous grammars, 123–126
Unary assignment data types,
338–339
Unary operators, 319
Unchecked exceptions, 650
Unconditional branch statements,
375–376
undef, 145–147
undefined, 264
Underflow, 332
Ungar, David, 548
Unicode, 249
Unification, 733, 759
Uninstantiated variables, 737
union, 285, 308
Union types
in Ada, 285–287
design issues for, 285
discriminated vs. free unions
in, 285
evaluation of, 288
in F#, 287–288
implementation of, 289
introduction to, 284
Unit-level concurrency. see
subprogram-level
UNIVAC, 40–41
UNIVAC Scientific Exchange
(USE), 53
University of Aix-Marseille, 79,
736
University of Edinburgh, 79, 736
University of Utah, 85
UNIX
programming environment of,
31
readability of, 13
systems software for, 6–7
Unlimited extent, 431
unsafe, C#, 296
USE (UNIVAC Scientific
Exchange), 53
use clause, 484, 516
User-defined
abstract data types,
476–478
ordinal data types. see Ordinal
data types
overloaded data types, 430
User-located loop control mecha-
nisms, 370–371
using directive, 515
V
val statements, 341, 704–706
Value, 209
Value types, 290
var declarations, 211–212
Variables
addresses of, 208
defined, 245
names of, 208
names vs., 207–209
type of, 209
value of, 209
Variable-size cells, 301
VAX minicomputers, 10
VB (Visual BASIC), 13
VDL (Vienna Definition
Language), 142
Vector processors, 578
Vienna Definition Language
(VDL), 142
virtual method tables (vtables),
566–568
virtual reserved word,
545, 557
Visible variables, 218
Visual BASIC (VB), 13, 65–67
Visual languages, 22
Visual Studio, 22, 31
void, 11, 389–393
void * pointers, 295
vtables (virtual method tables),
566–568
W
wait semaphores, 586–590
Wall, Larry, 95
Weakest preconditions
in assignment statements,
150–152
in axiomatic semantics,
149–150
in logical pretest loops,
154–158
in sequences, 152–153
Web software, 7
Weinberger, Peter, 95
Well-definedness, 18
Wheeler, David J., 42
when clauses, 598–599
\n Index     795
while
for assignments as expressions,
339
in C#, 616
in Java, 92, 609
in logically controlled loops,
368–370
loops, 154–158
in short-circuit evaluations,
335
as special word, 12
syntax of, 114–115
in user-located loop control
mechanisms, 371
Whitaker, Lt. Col. William, 81
Widening type conversions, 329
Widgets, 655–656
van Wijngaarden
grammars, 74
Wildcard types, 426
Wileden, J. C., 227
Wilkes, Maurice V., 42
Windows, 66–67
Wirth, Niklaus, 75, 379
with clauses
in Ada, 484
in Ada packages, 516, 562
Wolf, A. L., 227
Woodenman requirements
document, 82
Wrapper classes, 530
Writability, 13, 16
X
Xerox Palo Alto Research Center
(Xerox PARC), 86
XML (eXtensible Markup
Language), 104–106
XSLT (eXtensible Stylesheet
Language Transformations),
22, 104–105
Y
yacc, 132
yield methods, 605
Z
Zuse, Konrad, 38
