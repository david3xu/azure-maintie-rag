Bibliography    769
Newell, A., and H. A. Simon. (1956) “The Logic Theory Machine—A Complex Information
Processing System.” IRE Transactions on Information Theory, Vol. IT-2, No. 3, pp. 61–79.
Newell, A., and F. M. Tonge. (1960) “An Introduction to Information Processing Language V.”
Commun. ACM, Vol. 3, No. 4, pp. 205–211.
Nilsson, N. J. (1971) Problem Solving Methods in Artificial Intelligence. McGraw-Hill, New York.
Ousterhout, J. K. (1994) Tcl and the Tk Toolkit. Addison-Wesley, Reading, MA.
Paepcke, E. (editor). Object-Oriented Programming: The CLOS Perspective. MIT Press, 1993.
Pagan, F. G. (1981) Formal Specifications of Programming Languages. Prentice-Hall, Englewood
Cliffs, NJ.
Papert, S. (1980) MindStorms: Children, Computers and Powerful Ideas. Basic Books, New York.
Perlis, A., and K. Samelson. (1958) “Preliminary Report—International Algebraic Language.”
Commun. ACM, Vol. 1, No. 12, pp. 8–22.
Peyton Jones, S. L. (1987) The Implementation of Functional Programming Languages. Prentice-Hall,
Englewood Cliffs, NJ.
Pratt, T. W. (1984) Programming Languages: Design and Implementation, 2e. Prentice-Hall,
Englewood Cliffs, NJ.
Pratt, T. W., and M. V. Zelkowitz (2001) Programming Languages: Design and Implementation, 4e.
Prentice-Hall, Englewood Cliffs, NJ.
Raymond, E. (2004) Art of UNIX Programming. Addison Wesley, Boston.
Remington-Rand. (1952) “UNIVAC Short Code.” Unpublished collection of dittoed notes. Preface
by A. B. Tonik, dated October 25, 1955 (1 p.); Preface by J. R. Logan, undated but apparently
from 1952 (1 p.); Preliminary exposition, 1952? (22 pp., where in which pp. 20–22 appear
to be a later replacement); Short code supplementary information, topic one (7 pp.); Addenda
#1, 2, 3, 4 (9 pp.).
Reppy, J. H. (1999) Concurrent Programming in ML. Cambridge University Press, New York.
Richards, M. (1969) “BCPL: A Tool for Compiler Writing and Systems Programming.” Proc.
AFIPS SJCC, Vol. 34, pp. 557–566.
Robinson, J. A. (1965) “A Machine-Oriented Logic Based on the Resolution Principle.” Journal of
the ACM, Vol. 12, pp. 23–41.
Romanovsky, A. and B. Sandén (2001) “Except for Exception Handling,” Ada Letters, Vol. 21, No. 3,
September 2001, pp. 19–25.
Roussel, P. (1975) “PROLOG: Manual de Reference et D’utilisation.” Research Report. Artificial
Intelligence Group, Univ. of Aix-Marseille, Luming, France.
Rubin, F. (1987) “‘GOTO Statement Considered Harmful’ considered harmful” (letter to editor).
Commun. ACM, Vol. 30, No. 3, pp. 195–196.
Rutishauser, H. (1967) Description of ALGOL 60. Springer-Verlag, New York.
Sammet, J. E. (1969) Programming Languages: History and Fundamentals. Prentice-Hall, Engle-
wood Cliffs, NJ.
Sammet, J. E. (1976) “Roster of Programming Languages for 1974–75.” Commun. ACM, Vol. 19,
No. 12, pp. 655–669.
Schneider, D. I. (1999) An Introduction to Programming Using Visual BASIC 6.0. Prentice-Hall,
Englewood Cliffs, NJ.
Schorr, H., and W. Waite. (1967) “An Efficient Machine Independent Procedure for Garbage
Collection in Various List Structures.” Commun. ACM, Vol. 10, No. 8, pp. 501–506.
Scott, D. S., and C. Strachey. (1971) “Towards a Mathematical Semantics for Computer Language.”
In Proceedings, Symposium on Computers and Automation, J. Fox (ed.). Polytechnic Institute of
Brooklyn Press, New York, pp. 19–46.
Scott, M. (2000) Programming Language Pragmatics, Morgan Kaufman, San Francisco, CA.
Sebesta, R. W. (1991) VAX Structured Assembly Language Programming, 2e. Benjamin/Cummings,
Redwood City, CA.
Sergot, M. J. (1983) “A Query-the-User Facility for Logic Programming.” In Integrated Interactive
Computer Systems, P. Degano and E. Sandewall (eds.). North-Holland Publishing, Amsterdam.
Shaw, C. J. (1963) “A Specification of JOVIAL.” Commun. ACM, Vol. 6, No. 12, pp. 721–736.
Smith, J. B. (2006) Practical OCaml. Apress, Springer-Verlag, New York.
Sommerville, I. (2005) Software Engineering, 7e. Addison-Wesley, Reading, MA.
\n770   Bibliography
Steele, G. L., Jr. (1990) Common LISP The Language, 2nd ed. Digital Press, Burlington, MA.
Stoy, J. E. (1977) Denotational Semantics: The Scott–Strachey Approach to Programming Language
Semantics. MIT Press, Cambridge, MA.
Stroustrup, B. (1983) “Adding Classes to C: An Exercise in Language Evolution.” Software—
Practice and Experience, Vol. 13, pp. 139–161.
Stroustrup, B. (1984) “Data Abstraction in C.” AT&T Bell Laboratories Technical Journal, Vol. 63,
No. 8.
Stroustrup, B. (1986) The C++ Programming Language. Addison-Wesley, Reading, MA.
Stroustrup, B. (1988) “What Is Object-Oriented Programming?” IEEE Software, May 1988,
pp. 10–20.
Stroustrup, B. (1991) The C++ Programming Language, 2e. Addison-Wesley, Reading, MA.
Stroustrup, B. (1994) The Design and Evolution of C++. Addison-Wesley, Reading, MA.
Stroustrup, B. (1997) The C++ Programming Language, 3e. Addison-Wesley, Reading, MA.
Sussman, G. J., and G. L. Steele, Jr. (1975) “Scheme: An Interpreter for Extended Lambda Calculus.”
MIT AI Memo No. 349 (December 1975).
Suzuki, N. (1982) “Analysis of Pointer ‘Rotation.”’ Commun. ACM, Vol. 25, No. 5, pp. 330–335.
Syme, D., A. Granicz, and A. Cisternino. (2010) Expert F# 2.0. Apress, Springer-Verlag, New York.
Tanenbaum, A. S. (2005) Structured Computer Organization, 5e. Prentice-Hall, Englewood
Cliffs, NJ.
Tenenbaum, A. M., Y. Langsam, and M. J. Augenstein. (1990) Data Structures Using C. Prentice-Hall,
Englewood Cliffs, NJ.
Teitelbaum, T., and T. Reps. (1981) “The Cornell Program Synthesizer: A Syntax-Directed Pro-
gramming Environment.” Commun. ACM, Vol. 24, No. 9, pp. 563–573.
Teitelman, W. (1975) INTERLISP Reference Manual. Xerox Palo Alto Research Center, Palo Alto,
CA.
Thomas, D., C. Fowler, and A. Hunt. (2005) Ruby: The Pragmatic Programmers Guide, 2e, The
Pragmatic Bookshelf, Raleigh, NC.
Thompson, S. (1999) Haskell: The Craft of Functional Programming, 2e. Addison-Wesley, Reading,
MA.
Turner, D. (1986) “An Overview of Miranda.” ACM SIGPLAN Notices, Vol. 21, No. 12, pp. 158–166.
Ullman, J. D. (1998) Elements of ML Programming. ML97 Edition. Prentice-Hall, Englewood
Cliffs, NJ.
van Emden, M.H. (1980) “McDermott on Prolog: A Rejoinder.” SIGART Newsletter, No. 72,
August, pp. 19–20.
van Wijngaarden, A., B. J. Mailloux, J.E.L. Peck, and C.H.A. Koster. (1969) “Report on the Algo-
rithmic Language ALGOL 68.” Numerische Mathematik, Vol. 14, No. 2, pp. 79–218.
Wadler, P. (1998) “Why No One Uses Functional Languages.” ACM SIGPLAN Notices, Vol. 33,
No. 2, February 1998, pp. 25–30.
Wall, L., J. Christiansen, and J. Orwant. (2000) Programming Perl, 3e. O’Reilly & Associates,
Sebastopol, CA.
Warren, D.H.D., L. M. Pereira, and F.C.N. Pereira. (1979) “User’s Guide to DEC System-10
Prolog.” Occasional Paper 15. Department of Artificial Intelligence, Univ. of Edinburgh,
Scotland.
Watt, D. A. (1979) “An Extended Attribute Grammar for Pascal.” ACM SIGPLAN Notices,
Vol. 14, No. 2, pp. 60–74.
Wegner, P. (1972) “The Vienna Definition Language.” ACM Computing Surveys, Vol. 4, No. 1,
pp. 5–63.
Weissman, C. (1967) LISP 1.5 Primer. Dickenson Press, Belmont, CA.
Wexelblat, R. L. (ed.) (1981) History of Programming Languages. Academic Press, New York.
Wheeler, D. J. (1950) “Programme Organization and Initial Orders for the EDSAC.” Proc. R. Soc.
London, Ser. A, Vol. 202, pp. 573–589.
Wilkes, M. V. (1952) “Pure and Applied Programming.” In Proceedings of the ACM National
Conference, Vol. 2. Toronto, pp. 121–124.
\nBibliography    771
Wilkes, M. V., D. J. Wheeler, and S. Gill. (1951) The Preparation of Programs for an Electronic
Digi tal Computer, with Special Reference to the EDSAC and the Use of a Library of Subrou-
tines. Addison-Wesley, Reading, MA.
Wilkes, M. V., D. J. Wheeler, and S. Gill. (1957) The Preparation of Programs for an Electronic
Digital Computer, 2e. Addison-Wesley, Reading, MA.
Wilson, P. R. (2005) “Uniprocessor Garbage Collection Techniques.” Available at http://www
.cs.utexas.edu/users/oops/papers.htm#bigsurv.
Wirth, N. (1971) “The Programming Language Pascal.” Acta Informatica, Vol. 1, No. 1,
pp. 35–63.
Wirth, N. (1973) Systematic Programming: An Introduction. Prentice-Hall, Englewood Cliffs, NJ.
Wirth, N. (1975) “On the Design of Programming Languages.” Information Processing 74 (Pro-
ceedings of IFIP Congress 74). North Holland, Amsterdam, pp. 386–393.
Wirth, N. (1977) “Modula: A Language for Modular Multi-Programming.” Software—Practice
and Experience, Vol. 7, pp. 3–35.
Wirth, N. (1985) Programming in Modula-2, 3e. Springer-Verlag, New York.
Wirth, N. (1988) “The Programming Language Oberon.” Software—Practice and Experience,
Vol. 18, No. 7, pp. 671–690.
Wirth, N., and C.A.R. Hoare. (1966) “A Contribution to the Development of ALGOL.” Commun.
ACM, Vol. 9, No. 6, pp. 413–431.
Wulf, W. A., D. B. Russell, and A. N. Habermann. (1971) “BLISS: A Language for Systems Pro-
gramming.” Commun. ACM, Vol. 14, No. 12, pp. 780–790.
Zuse, K. (1972) “Der Plankalkül.” Manuscript prepared in 1945, published in Berichte der
Gesellschaft für Mathematik und Datenverarbeitung, No. 63 (Bonn, 1972); Part 3, 285 pp.
English translation of all but pp. 176–196 in No. 106 (Bonn, 1976), pp. 42–244.
\nThis page intentionally left blank
\n773
A
Absolute addressing
manual, 207
pointers and, 297
problems with, 40, 42
Abstract cells, 209
Abstract classes
in Ada, 561–562
in C++, 547
introduction to, 529
in Java, 555
Abstract data types
design issues for, 478–479
floating-point as, 476
introduction to, 474
in Ada, 482–485, 503–504
in C++, 485–490,
505–506
in C#, 497–499
in C# 2005, 509
in Java, 496–497, 506–509
in Java 5.0, 506–509
in Objective-C, 490–496
parameterized, 503–509
problem set on, 520–521
in Ruby, 499–503
for stacks, 478
summary of, 517–518
user-defined, 476–478
Abstract methods, 529
Abstraction
beginnings of, 72–73
in BNF, 118
in imperative programming
languages, 204
support for, 14, 21
Accept clause body, 595
Accept clauses, 595–600
Access
deep vs. shallow, 462–466
to heaps, 289
in nested subprograms,
454–460
nonblocking synchronized, 612
in subprogram linkage, 442
types, 293
ACM (Association for Computing
Machinery)
GAMM and, 53, 117
Grace Murray Hopper Award
of, 480, 536
Turing Award of, 672
Activation record instances,
444–445
Index
\n![Image](images/page795_image1.png)
\n774     Index
Activation records, 444–445
Active subprograms
characteristics of, 389
in referencing environments,
231
stack-dynamic local variables
and, 448
Actor tasks, 596
Actual parameters, 392
Ad hoc binding, 418–419
Ad hoc polymorphism, 422
Ada
95 version of. see Ada 95
2005 version of, 84–85
abstract data types in,
482–485, 503–504
competition synchronization in,
599–601
compiler implementation in,
25
concurrency in, 21, 594–603
continuation in, 638–639
cooperation synchronization
in, 599
costs of, 17
design process for, 81–82
encapsulation constructs in,
482
evaluation of, 83–84
exception handling in, 16,
636–643
historical background of, 81
information hiding in,
482–483
language overview of, 82–83
packages in, 512, 516
pointer types in, 293
priorities of tasks in, 601–602
protected objects in, 602–603
task termination in, 601
Ada 95
child packages in, 562
dynamic binding in, 561–562
inheritance in, 559–560
introduction to, 84–85
object-oriented programming
in, 21, 558–563
Addresses
fields for, 687
of simple subprograms,
443–445
of stack-dynamic local
 variables, 445–449
of variables, 208
Adopting protocols, 551
Aggregate values, 265
Aho, Al, 95
AI (artificial intelligence)
introduction to, 6
LISP in, 47–48, 50
Project at MIT, 680
ALGOL 58
design process for, 53–54
overview of, 54
report on, 55
ALGOL 60
ALGOL 58 vs., 53–55
BNF in, 117–118
design process for, 55–56
evaluation of, 56–58
historical background of, 53
introduction to, 4–5, 52
overview of, 56
ALGOL 68
design process for, 73
evaluation of, 74–75
language overview of, 74
orthogonality in, 11, 73
ALGOL Bulletin, 55
Aliases, 208
Aliasing, 16
Allocation, 214, 532–533
Ambiguous grammars, 122–123
AND operators, 333–336
and then operators, 15, 336
Anonymous variables, 290
ANSI (American National
Standards Institute)
on Ada, 82
on C, 78
Minimal BASIC standard of,
64
Antecedents, 149, 731–732
APES system, 758
APL (A Programming Language)
as dynamic language,
generally, 71
introduction to, 14–15
origins and characteristics of,
71–72
trade-offs in, 23
append operations, 747–750
Apple, 90
Apply-to-all functional forms, 676,
697–698
APT (Automatically Programmed
Tools), 22
Arithmetic expressions
associativity in, 321–323
coercion in, 330–331
conditional, 325
errors in, 332
explicit type conversions and,
331–332
introduction to, 319
in LISP, 324
operand evaluation order in,
319–325
operand evaluation order in,
325–328
operator overloading and,
328–329
parentheses in, 323–324
precedence in, 319–321
in Prolog, 743–746
referential transparency in,
327–328
in Ruby, 324
side effects in, 325–328
type conversions and, 329–332
Array types
array initialization in, 264–265
array operations in, 266–267
categories in, 262–264
design issues for, 260
\n Index     775
evaluation of, 269
formal parameters, 394
implementation of, 269–272
indices and, 260–262
introduction to, 259–260
jagged arrays in, 267–268
rectangular arrays in,
267–268
slices in, 268–269
subscript bindings in,
262–264
Artificial intelligence (AI). see AI
(artificial intelligence)
ASCII (American Standard Code
for Information Interchange),
249
Assemblies, .NET, 512
Assertions
in axiomatic semantics,
148–149
in Java, 653–654
Assignment statements
in axiomatic semantics,
150–152
compound assignment
operators in, 337
conditional targets and, 337
in denotational semantics, 146
as expressions, 339–340
in functional programming
languages, 340–341
introduction to, 318
mixed-mode, 341
multiple, 340
problem set on, 343–345
programming exercises on,
345–346
review questions on, 342–343
simple, 336–337
summary of, 341–342
syntax of, 118, 121–122, 127
unary assignment data types
in, 338–339
Association for Computing
Machinery (ACM), 53
Associative arrays
implementation of, 276
introduction to, 272
structure and operations of,
272–276
Associativity, 126–128,
321–323
Atomic propositions, 729
Atoms, Prolog, 737
Attribute computation functions,
133
Attribute grammars
basic concepts of, 133–134
computing attribute values in,
137–138
defined, 134
evaluation of, 138–139
examples of, 135–136
intrinsic attributes in, 134–135
introduction to, 132–133
static semantics and, 133
Attributes
binding, 209–210
defined, 133
instance data as, 501
intrinsic, 134–135
Automatic generalization, 427
Automatic programming, 41
Automatically Programmed Tools
(APT), 22
awk scripting language, 95
Axiomatic semantics
assertions in, 148–149
assignment statements in,
150–152
evaluation of, 160–161
introduction to, 148
logical pretest loops in,
154–158
program proofs in, 158–160
selection in, 153–154
sequences in, 152–153
weakest preconditions in,
149–150
Axioms, 149
B
B, language, 77
Babbage, Charles, 82, 388
Backtracking, 742
Backus, John
Fortran by, 20, 41–43
on functional vs. imperative
languages, 672–673
on syntax, 117
Backus-Naur Form (BNF). see
BNF (Backus-Naur Form)
Backward chaining, 741–742
base prefix, 557
BASIC
design process for, 63–64
evaluation of, 64–65
introduction to, 18
timesharing in, generally, 63
BASIC-PLUS, 64
Bauer, Fritz, 53
BCD (binary coded decimal), 248
Bell Laboratories. see AT&T Bell
Laboratories
BINAC computer, 40
binary coded decimal (BCD), 248
Binary operators, 319
Binary semaphors, 589
Binding
ad hoc, 418–419
attributes to variables,
209–210
deep, 418–419
dynamic. see Dynamic binding
dynamic type, 212–214
exceptions to handlers, Ada,
637–638
exceptions to handlers, C++,
644
exceptions to handlers, Java,
648–649
explicit heap-dynamic variables
in, 216–218
implicit heap-dynamic
variables in, 218
introduction to, 204
\n776     Index
Binding (continued)
lifetime of, 214–215
overview of, 209–210
shallow, 418–419
stack-dynamic variables in,
215–216
static type, 211–212
static variables in, 215
storage, 214–215
subscript, 262–264
type, 210–214
Binding time, 209
BLISS, 6
Blocked tasks, 584
Blocks
in Ruby, 374
for scope, 220–223
in subprograms, implementing,
460–462
Block-structured language,
56, 220
BNF (Backus-Naur Form)
analyzing syntax in, 169
describing lists in, 119
expressions in, 145
Extended, 129–132
fundamentals of, 118–119
if-then-else statements
in, 128–129
introduction to, 55–57
static semantics in, 133
syntax and, 117–118
Body packages, 482–484
Böhm, Corrado, 350, 379
Boolean abstract data types,
497–498
Boolean data types, 249
Boolean expressions, 332–335, 340
boolean type variables, 92, 255,
612
Borland JBuilder, 31
Bottom-up parsers
introduction to, 180
LR parsers and, 193–197
problem for, 190–192
shift-reduce algorithms for,
192–193
Bottom-up resolution, 741
Bound variables, 682–683
Bounded wildcard types, 426
Bounds, 425–426
Boxing, 552
Breadth-first searches, 742
break statements
guarded commands and, 379
multiple-selection statements
and, 355–358
in user-located loop control
mechanisms, 370–371
Brinch Hansen, Per, 590–591,
593–594
Business applications, 5–6
Business record computerization.
see COBOL
Byron, Augusta Ada, 82
Byte code, 30
byte operands, 320, 331
C
C
abstraction support in, 14
compiler implementation in, 25
encapsulation constructs in,
510–511
evaluation of, 78–79
expressivity in, 15
historical background of, 77–78
language categories in, 22
orthogonality in, 11
pointer types in, 294–295
popularity of, 3
portable system of, generally, 77
preprocessors in, 30
systems software in, 6–7
type checking in, 15
writability of, 13
C#
2005 version of, 509
abstract data types in,
497–499, 509
assemblies in, 512–513
concurrency in, 21
design process for, 101–102
dynamic binding in, 557–558
encapsulation constructs in,
498
evaluation of, 103–104
event handling in, 661–664
information hiding in, 498–499
inheritance in, 557
language overview of, 102–103
nested classes in, 558
as .NET language, 101
object-oriented programming
in, 556–558
overview of, 101–104
threads in, 613–618
C++
abstract data types in,
485–490, 505–506
abstraction support in, 14
compiler implementation
in, 25
constructors in, 487
continuation in, 644–645
design process for, 88–89
destructors in, 487
dynamic binding in, 544–547
encapsulation constructs in,
486, 511–512
evaluation of, 89
exception handling in, 16,
643–647
imperative features in,
generally, 88
information hiding in, 486
inheritance in, 539–544
language overview of, 89
namespaces in, 514–515
object-oriented programming
in, 88, 538–539,
547–549
orthogonality in, 11–12
pointer types in, 294–295
popularity of, 3
\n Index     777
systems software in, 6
trade-offs in, 23
Call chains, 450
Calls
dynamic binding of method,
566–568
indirect, 419–421
semantics of subprogram,442
Cambridge Polish, 679
Cambridge University, 77
Camel notation, 205
Caml, 52
canonical LR algorithm, 193
CAR functions, 687–688,
691–694
Case expressions, 357–359
Case sensitivity, 206
case statements, 75, 359–361
catch, 643, 648–649
Category interfaces, 550
C-based languages, 204–206
CBL (Common Business
Language), 59
CDE (Solaris Common Desktop
Environment), 31
CDR functions, 687–688,
691–694
Celes, Waldemar, 100
central processing units (CPUs),
18–19
CGI (Common Gateway Interface),
97, 99
chain_offset, 455
Chambers, Craig, 548
char arrays, 250–251, 265
char ordinal types, 255
Character string types
design issues for, 250
evaluation of, 253
implementation of, 253–255
string length options in,
252–253
string operations in, 250–252
type checking in, 302–303
Checked exceptions, 650
Child library packages, 562
Child packages, 562
Chomsky, Noam, 117
Church, Alonzo, 675
Cii Honeywell/Bull language, 82
Clark, K. L., 737
Clarke, L. A., 227
class instance records (CIRs),
566–568
Class methods, 527
Class variables, 527
Classes
abstract, 529, 547
derived, 526, 540–544
of exceptions, 647
inner, 555–556
interface abstract, 553–555
interlocked, 616
local nested, 556
nested, 533, 555–556, 558
parent, 526–527
sub, 526
super, 526
wrapper, 530
Clausal form, 350–351, 731–732
Clients, 477
Clocksin, W. F., 753
CLOS (Common LISP Object
System), 21, 701
Closed accept clauses, 599
Closed-world assumption, 754
Closures, 430–432
CML (Concurrent ML), 619
COBOL
compiler implementation in,
25
computerizing business records
in, 58
design process for, 59–60
evaluation of, 60–63
FLO-MATIC and, 59
historical background of, 59
introduction to, 5–6
Code-building functions, SCHEME,
698–699
Coercions
in arithmetic expressions,
330–331
for deproceduring, 74
in type checking, 302
Colmerauer, Alain, 79, 736
Column major order, 270
Common Business Language
(CBL), 59
Common Gateway Interface (CGI),
97, 99
Common Intermediate Language
(CIL), 512
Common LISP, 51–52, 699–701
Common LISP Object System
(CLOS), 21, 701
Communicating Sequential
Processes (CSP), 597
Communications of the ACM, 55,
672
Compatible types, 302, 530
Competition synchronization
in Ada, 599–601
in concurrency, generally,
589–590
introduction to, 581–585
in Java, 607–608
with monitors, 591
with semaphores, 589–590
Compiler design, 4
Compiler implementation, 24–28
Completed tasks, 601
Complex data types, 248
Compound assignment operators,
337
Compound terms, 729
Computer architecture, 18–20
Concurrency
in Ada, 594–603
C# threads in, 613–618
categories of, 579–580
competition synchronization
in, 589–591, 598–601,
607–608
in Concurrent ML, 619
\n778     Index
Concurrency (continued)
cooperation synchronization in,
586–589, 591–592
cooperation synchronization in,
Ada, 599
cooperation synchronization in,
Java, 608–611
design issues for, 585–586
explicit locks in, Java 5.0,
612–613
in F#, 620–621
in functional languages,
618–621
in High-Performance Fortran,
621–623
introduction to, 21, 576–581
in Java threads. see Threads
language design for, 585
message passing in, 593–594
monitors in, 591–593
in Multilisp, 618
multiprocessor architectures
in, 577–579
nonblocking synchronization
in, 612
protected objects in, 602–603
reasons for using, 580–581
semaphores in, 586–590, 607
statement-level, 621–623
subprogram-level, 581–586
synchronizing threads in,
616–617
synchronous message passing
in, 593–594
task priorities in, 601–602
task termination in, 601
thread priorities in, 606–607
Concurrent Pascal, 591
Concurrent ML (CML), 619
Conditional expressions, 325, 708
Conditional targets, 337
Conjunctions, 738
CONS function, 688–694
Consequents, 149, 731–732
const constants, 233
Constrained variant variables,
285–287
Constraint_Error
exceptions, 639–642
Constructors, 487
Context-free grammars, 117–118
Continuation, 634–635
Control expressions, 350
Control flow, 685–686
Control statements, 348
Control structures, 349
Cooper, Alan, 66
Cooper, Jack, 82
Cooperation synchronization
in Ada, 599
in concurrency, 586–589
introduction to, 581–585
in Java, 608–611
with monitors, 591–592
with semaphores, 586–589
Coroutines, 73, 432–435
Costs of languages, 16–18
Counter-controlled loops, 363,
367–368
in Ada, 364
in C-based languages,
364–366
in functional languages,
367–368
in Python, 366–367
Cox, Brad, 90
CPUs (central processing units),
18–19
CSP (Communicating Sequential
Processes), 597
Currie, Malcolm, 81
Currying, 706
Cut Prolog, 752–753
D
Dahl, Ole-Johan, 72–73
Dangling pointers, 292–293
Dangling references, 294
Data abstraction. see Abstraction
Data members, 486, 539
Data structures, 371–375
Data types
array. see Array types
associative array, 272–276
boolean, 249
character, 249–250
character string, 250–255
complex, 248
decimal, 248–249
equivalence in, 304–308
floating point, 247–248
integer, 246–247
introduction to, 12, 244–246
in LISP, 677–678
list, 281–284
numeric, 246–249
ordinal, 255–258
pointer, 289–295, 297–302
primitive, 246–250
problem set on, 314–315
programming exercises on,
315–316
record, 276–280
reference, 290, 295–302
review questions on, 312–313
string length options in,
252–253
string operations in,
250–252
strong typing, 303–304
summary of, 310–311
theory and, 308–310
tuple, 280–281
union, 284–289
Dead tasks, 584
Deadlocks, 585
Deallocation, 214, 532–533
Decimal data types, 248–249
Declaration order, 223–224
Declarative languages, 728,
734–735
declare blocks, Ada, 263
Decorating parse trees, 137
Decrement fields, 687
Deep access, 462–464
